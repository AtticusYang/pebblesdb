Design of GuardMetadata
- just have different versions
- have them point to FileMetaData vector
- have them be ref counted
- just make sure that FileMetaData cannot be deleted while
  GuardMetaData holds a ref to it

Version needs to have pointers to GuardMetaData in each level.
- vectors of GuardMetaData per level (kind of like FileMetaData
  vectors per level)

Changes that can happen to a level needs to incorporate changes to
guards too
- adding a guard
- deleting a guard
- adding a file to a guard
- deleting a file from a guard

invariant: every file added must belong to some guard.
- add this to FileMetaData?

Need to keep guards vector sorted inside version.
- or maybe just sort in FindGuard?

Inserting guards
================
- Does this need to be crash recoverable?
- Does this need to be in the log?

- The problem with writing it seperately is that if the guard is
  present but the key is not in the store, its inconsistent. We could
  create fake guards, crash the system, and then FLSM would not get
  good performance.

- Lets just consider whether a key is a guard or not at the point of
  compaction of Level 0. At this point, the data is already durable,
  so we just need to add a record to the manifest saying that a new
  guard file has been established.

- Any changes need to go through the versionEdit data structure.
  Modifying that so that we can have guard functionality.
  LogAndApply() in VersionSet should know to apply guard changes.

Questions
- Should FileMetaData contain a pointer to the guard?
  - how would we set up this?
- Should GuardMetdata contain a list of files under it?
  - how would we write this to disk and recover it?
  - just record the file numbers.
  
